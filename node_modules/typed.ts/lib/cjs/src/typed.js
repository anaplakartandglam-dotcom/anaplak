"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Typed = void 0;
const keyboards_js_1 = require("./data/keyboards.js");
const random_char_js_1 = require("./utils/random-char.js");
const resetter_js_1 = require("./utils/resetter.js");
const is_special_char_js_1 = require("./utils/is-special-char.js");
const wait_js_1 = require("./utils/wait.js");
const default_part_name_js_1 = require("./utils/default-part-name.js");
const queue_manager_js_1 = require("./types/queue-manager.js");
class Typed {
    /**
     * Creates a factory function that can be used to create Typed instances with a custom setup.
     * This is useful if you do not want to rely on a callback function to update the text, but rather on a different data structure.
     * @param customOptions The custom setup options.
     * @returns A factory function that can be used to create Typed instances with a custom setup.
     * @example
     * ```ts
     * const typedFactory = Typed.factory({
     *   setUp: () => new BehaviorSubject(''),
     *   update: (textSubj, text) => textSubj.next(text)
     * });
     * // Create a new Typed instance with the custom setup
     * const typed = typedFactory({
     *  // some options
     * });
     * // access the text BehaviorSubject
     * typed.text.subscribe(text => console.log(text));
     * ```
     */
    static factory(customOptions) {
        return (options) => new Typed(options !== null && options !== void 0 ? options : {}, customOptions);
    }
    /**
     * Returns the text data structure that was configured using the factory function.
     * @throws If the factory function was not used to create this instance.
     */
    get text() {
        if (!this._setupUpdater) {
            throw new Error('To use this property, use the Typed.factory() function.');
        }
        return this._setupUpdater;
    }
    constructor(options, customSetup) {
        var _a, _b;
        this._resetter = new resetter_js_1.Resetter();
        this._randomChars = new random_char_js_1.RandomChars();
        this._resultItems = [];
        this._fastForward = false;
        this._lettersSinceLastError = 0;
        this._endResultItems = [];
        this._fastForwardOptions = {
            perLetterDelay: { min: 5, max: 20 },
            eraseDelay: { min: 5, max: 10 },
            errorMultiplier: 0,
        };
        this._options = options;
        if (customSetup) {
            const setupUpdater = customSetup.setUp();
            this._setupUpdater = setupUpdater;
            options.callback = (text) => customSetup === null || customSetup === void 0 ? void 0 : customSetup.update(setupUpdater, text);
            if (customSetup.namedParts) {
                this._options.namedParts = customSetup.namedParts;
            }
        }
        this._typeQueue = new queue_manager_js_1.QueueManager('type', this._resetter, (_a = this._options.namedParts) !== null && _a !== void 0 ? _a : [default_part_name_js_1.DEFAULT_PART_NAME]);
        this._ffQueue = new queue_manager_js_1.QueueManager('ff', this._resetter, (_b = this._options.namedParts) !== null && _b !== void 0 ? _b : [default_part_name_js_1.DEFAULT_PART_NAME]);
        this._queue = this._typeQueue;
    }
    getOptions(partName) {
        var _a;
        const defaultOptions = {
            callback: () => {
                // do nothing
            },
            eraseDelay: { min: 150, max: 250 },
            errorDelay: { min: 50, max: 100 },
            errorMultiplier: 1,
            noSpecialCharErrors: false,
            locale: 'en',
            perLetterDelay: { min: 40, max: 150 },
            namedParts: [default_part_name_js_1.DEFAULT_PART_NAME],
        };
        const ffOptions = this._fastForward
            ? this._fastForwardOptions
            : {};
        const currentQueueItemOptions = (partName && ((_a = this._queue.get(partName).item) === null || _a === void 0 ? void 0 : _a.options)) || {};
        return {
            ...defaultOptions,
            ...this._options,
            ...currentQueueItemOptions,
            ...ffOptions,
        };
    }
    /**
     * Adds a new keyboard layout to the list of available keyboards.
     * @param locale The locale of the keyboard layout.
     * @param keyboard The keyboard layout.
     * @example
     * ```
     * typed.addKeyboard('de', {
     *   lower: ['1234567890ß', 'qwertzuiopü+', 'asdfghjklöä#', 'yxcvbnm,.-', ' '],
     *   upper: ['!"§$%&/()=?', 'QWERTZUIOPÜ*', "ASDFGHJKLÖÄ'", 'YXCVBNM;:_', ' ']
     * });
     * ```
     * More info [here](https://github.com/LoaderB0T/typed.ts#Add-your-own-keyboard-layouts)
     */
    addKeyboard(locale, keyboard) {
        keyboards_js_1.keyboards[locale] = keyboard;
    }
    /**
     * Stops the current animation.
     * @param clearTexts Whether to clear the texts or not.
     * @returns A promise that resolves when the animation has stopped and can be started again.
     */
    async reset(clearTexts = false) {
        this._resultItems = [];
        this._fastForward = false;
        this.updateText();
        this._ffQueue.clear();
        if (clearTexts) {
            this._typeQueue.clear();
            while (this._endResultItems.pop()) {
                // do nothing
            }
        }
        await this._resetter.reset();
    }
    /**
     * Adds a string that will be typed out to the end of the queue.
     * @param sentance The string to type out.
     * @param options The options for typing.
     * @returns The Typed instance.
     */
    type(sentance, options) {
        var _a;
        const partName = (_a = options === null || options === void 0 ? void 0 : options.namedPart) !== null && _a !== void 0 ? _a : default_part_name_js_1.DEFAULT_PART_NAME;
        this._typeQueue.add({
            type: 'sentance',
            partName,
            text: sentance,
            options,
            className: options === null || options === void 0 ? void 0 : options.className,
        });
        this.addLetterTo(sentance, this._endResultItems, partName, options === null || options === void 0 ? void 0 : options.className);
        return this;
    }
    /**
     * Adds the deletion of a number of letters to the end of the queue.
     * @param length The number of letters to delete.
     * @param options The options for erasing.
     * @returns The Typed instance.
     */
    backspace(length, options) {
        var _a;
        const partName = (_a = options === null || options === void 0 ? void 0 : options.namedPart) !== null && _a !== void 0 ? _a : default_part_name_js_1.DEFAULT_PART_NAME;
        this._typeQueue.add({
            type: 'backspace',
            partName,
            length,
            options,
        });
        this.deleteLetterFrom(this._endResultItems, partName, length);
        return this;
    }
    /**
     * Adds a delay to the end of the queue.
     * @param delay The delay in milliseconds.
     * @returns The Typed instance.
     */
    wait(delay, options) {
        var _a;
        this._typeQueue.add({
            type: 'wait',
            partName: (_a = options === null || options === void 0 ? void 0 : options.namedPart) !== null && _a !== void 0 ? _a : default_part_name_js_1.DEFAULT_PART_NAME,
            delay,
        });
        return this;
    }
    /**
     * Runs the configured animation (queue).
     * @returns A promise that resolves when the animation has finished.
     */
    async run() {
        this._queue = this._typeQueue;
        this._typeQueue.resetIndices();
        this._resultItems = [];
        await this.doQueueAction();
    }
    /**
     * Fast forwards the current animation. Skipping all delays and only typing characters that are relevant for the end result.
     * @returns A promise that resolves when the animation has finished.
     */
    fastForward() {
        var _a;
        if (this._fastForward) {
            return;
        }
        const namedParts = ((_a = this._options.namedParts) === null || _a === void 0 ? void 0 : _a.length)
            ? this._options.namedParts
            : [default_part_name_js_1.DEFAULT_PART_NAME];
        this._ffQueue.clear();
        this._queue = this._ffQueue;
        namedParts.forEach(partName => this.ff(partName));
        this._fastForward = true;
        this._resetter.singleReset();
    }
    ff(partName) {
        const resultItemsForPart = this._resultItems.filter(item => item.partName === partName);
        const endResultItemsForPart = this._endResultItems.filter(item => item.partName === partName);
        let matchingLetterCount = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const currentTextAtIndex = this.getTextAtIndex(resultItemsForPart, matchingLetterCount);
            const endResultTextAtIndex = this.getTextAtIndex(endResultItemsForPart, matchingLetterCount);
            if (!currentTextAtIndex || !endResultTextAtIndex) {
                break;
            }
            if (currentTextAtIndex.letter === endResultTextAtIndex.letter &&
                currentTextAtIndex.className === endResultTextAtIndex.className) {
                matchingLetterCount++;
            }
            else {
                break;
            }
        }
        const currentTextWithoutClasses = this.getPartText(resultItemsForPart, false);
        const currentTextLength = currentTextWithoutClasses.length;
        const neededBackspaces = currentTextLength - matchingLetterCount;
        if (neededBackspaces) {
            this._ffQueue.add({
                type: 'backspace',
                partName,
                length: neededBackspaces,
            });
        }
        const resultTextLength = this.getPartText(endResultItemsForPart, false).length;
        for (let i = 0; i < resultTextLength - matchingLetterCount; i++) {
            const letter = this.getTextAtIndex(endResultItemsForPart, i + matchingLetterCount);
            this._ffQueue.add({
                type: 'sentance',
                partName,
                text: letter.letter,
                options: undefined,
                className: letter.className,
            });
        }
    }
    getTextAtIndex(resultItems, index) {
        let i = 0;
        let skipped = 0;
        while (resultItems[i]) {
            if (resultItems[i].text.length > index - skipped) {
                const letter = resultItems[i].text.substring(index - skipped, index - skipped + 1);
                const className = resultItems[i].className;
                return { letter, className };
            }
            else {
                skipped += resultItems[i].text.length;
                i++;
            }
        }
        return undefined;
    }
    async doSingleAction(partName, item) {
        switch (item.type) {
            case 'sentance':
                return this.typeLetter(partName);
            case 'backspace':
                return this.typeBackspace(partName);
            case 'wait':
                return this.waitItem(partName);
            default:
                throw new Error('Unknown queue item type');
        }
    }
    async doQueueActionForPart(partName) {
        let currentQueueItem = this._queue.get(partName).item;
        while (currentQueueItem) {
            const res = await this.doSingleAction(partName, currentQueueItem);
            if (!res) {
                return false;
            }
            currentQueueItem = this._queue.get(partName).item;
        }
        return true;
    }
    async doQueueAction() {
        const { promise, resolve } = Promise.withResolvers();
        const namedParts = this.getOptions(false).namedParts;
        const promises = namedParts.map(part => this.doQueueActionForPart(part));
        Promise.all(promises).then(() => {
            resolve(true);
        });
        return promise;
    }
    async typeLetter(partName) {
        const queue = this._queue.get(partName);
        const currentSentance = queue.item;
        const currentLetter = currentSentance.text[queue.detailIndex];
        await this.maybeDoError(currentSentance, 0, currentSentance.partName, queue);
        if (queue === this._queue.get(partName)) {
            this.addLetter(currentLetter, currentSentance.partName, currentSentance.className);
            this._lettersSinceLastError++;
            this.updateText();
            await (0, wait_js_1.wait)(this.getOptions(partName).perLetterDelay, this._resetter);
        }
        return this.incrementQueue(partName, queue, currentSentance.text.length);
    }
    async typeBackspace(partName) {
        const queue = this._queue.get(partName);
        const currentBackspaceItem = queue.item;
        if (currentBackspaceItem.length > 0) {
            this.deleteLetter(currentBackspaceItem.partName);
            this.updateText();
            await (0, wait_js_1.wait)(this.getOptions(partName).eraseDelay, this._resetter);
        }
        return this.incrementQueue(partName, queue, currentBackspaceItem.length);
    }
    async waitItem(partName) {
        const queue = this._queue.get(partName);
        if (!this._fastForward) {
            const currentWaitItem = queue.item;
            await (0, wait_js_1.wait)(currentWaitItem.delay, this._resetter);
        }
        return this.incrementQueue(partName, queue);
    }
    incrementQueue(partName, queue, maxDetailIndex) {
        if (queue === this._queue.get(partName)) {
            return queue.increment(maxDetailIndex);
        }
        else {
            return true;
        }
    }
    async shouldError(partName, currentWrongLettersCount, intendedChar, wasFF, nearbyChar) {
        const errorProbability = this.calculateErrorProbability(partName, currentWrongLettersCount);
        let willError = true;
        if (Math.random() > errorProbability) {
            willError = false;
        }
        if (!intendedChar) {
            willError = false;
        }
        if (this.getOptions(partName).noSpecialCharErrors && (0, is_special_char_js_1.isSpecialChar)(intendedChar)) {
            willError = false;
        }
        if (!nearbyChar) {
            willError = false;
        }
        if (!willError || !nearbyChar) {
            if (currentWrongLettersCount > 0) {
                if (!this._fastForward || wasFF) {
                    await (0, wait_js_1.wait)(this.getOptions(partName).errorDelay, this._resetter);
                }
            }
        }
        return willError;
    }
    async maybeDoError(currentSentance, currentWrongLettersCount, partName, queue) {
        const wasFF = this._fastForward;
        const intendedChar = currentSentance.text[queue.detailIndex + currentWrongLettersCount];
        const nearbyChar = this._randomChars.getRandomCharCloseToChar(intendedChar, this.getOptions(partName).locale);
        const shouldError = await this.shouldError(partName, currentWrongLettersCount, intendedChar, wasFF, nearbyChar);
        if (!shouldError || !nearbyChar) {
            return;
        }
        this._lettersSinceLastError = 0;
        this.addLetter(nearbyChar, partName, currentSentance.className);
        this.updateText();
        await (0, wait_js_1.wait)(this.getOptions(partName).perLetterDelay, this._resetter);
        if (!this._fastForward || wasFF) {
            await this.maybeDoError(currentSentance, currentWrongLettersCount + 1, partName, queue);
        }
        if (!this._fastForward || wasFF) {
            this.deleteLetter(partName);
            this.updateText();
        }
        if (!this._fastForward || wasFF) {
            await (0, wait_js_1.wait)(this.getOptions(partName).eraseDelay, this._resetter);
        }
    }
    calculateErrorProbability(partName, currentWrongLettersCount) {
        let errorProbability = 0;
        // The more correct letters we typed, the more likely we are to make an error
        errorProbability += (1 / 1000) * Math.pow(this._lettersSinceLastError, 2);
        // If we just made an error, the more likely we are to make another one
        if (currentWrongLettersCount === 1) {
            errorProbability += 0.4;
        }
        else if (currentWrongLettersCount === 2) {
            errorProbability += 0.2;
        }
        // Adjust based on the configured modifier
        return errorProbability * this.getOptions(partName).errorMultiplier;
    }
    addLetter(letter, partName, className) {
        this.addLetterTo(letter, this._resultItems, partName, className);
    }
    addLetterTo(letter, result, partName, className) {
        const lastResultItem = result[result.length - 1];
        if (lastResultItem &&
            lastResultItem.className === className &&
            lastResultItem.partName === partName) {
            lastResultItem.text += letter;
        }
        else {
            result.push({
                text: letter,
                className,
                partName,
            });
        }
    }
    deleteLetter(partName) {
        this.deleteLetterFrom(this._resultItems, partName);
    }
    deleteLetterFrom(result, partName, length = 1) {
        var _a;
        let needsAnotherDelete = false;
        const filteredResult = result.filter(item => item.partName === partName);
        do {
            let deleteAmountForThisItem = length;
            const lastResultItem = filteredResult[filteredResult.length - 1];
            if (!lastResultItem) {
                if (this._resetter.isReset) {
                    // might happen due to still running code during reset
                    return;
                }
                throw new Error('Cannot delete letter from empty text');
            }
            const maxDeletableAmount = (_a = lastResultItem === null || lastResultItem === void 0 ? void 0 : lastResultItem.text.length) !== null && _a !== void 0 ? _a : 0;
            if (maxDeletableAmount < length) {
                deleteAmountForThisItem = maxDeletableAmount;
                length -= maxDeletableAmount;
                needsAnotherDelete = true;
            }
            lastResultItem.text = lastResultItem.text.slice(0, -deleteAmountForThisItem);
            if (!lastResultItem.text) {
                filteredResult.pop();
                const indexInResult = result.indexOf(lastResultItem);
                if (indexInResult !== -1) {
                    result.splice(indexInResult, 1);
                }
            }
        } while (needsAnotherDelete);
    }
    updateText() {
        var _a, _b;
        if (this._resetter.isReset) {
            return;
        }
        const text = this.getCurrentText(this._resultItems);
        if (!((_a = this._options.namedParts) === null || _a === void 0 ? void 0 : _a.length)) {
            this._options.callback((_b = text[default_part_name_js_1.DEFAULT_PART_NAME]) !== null && _b !== void 0 ? _b : '');
        }
        else {
            this._options.callback(text);
        }
    }
    getPartText(part, includeClasses = true) {
        return part
            .map(item => {
            if (item.className && includeClasses) {
                return `<span class="${item.className}">${item.text}</span>`;
            }
            else {
                return item.text;
            }
        })
            .join('');
    }
    getCurrentText(result, includeClasses = true) {
        var _a;
        const parts = result.reduce((x, y) => {
            (x[y.partName] = x[y.partName] || []).push(y);
            return x;
        }, {});
        const resultText = {};
        for (const [partName, part] of Object.entries(parts)) {
            if (!part) {
                throw new Error(`Part ${partName} is empty`);
            }
            resultText[partName] = this.getPartText(part, includeClasses);
        }
        for (const part of (_a = this._options.namedParts) !== null && _a !== void 0 ? _a : []) {
            if (!resultText[part]) {
                resultText[part] = '';
            }
        }
        return resultText;
    }
}
exports.Typed = Typed;
//# sourceMappingURL=typed.js.map